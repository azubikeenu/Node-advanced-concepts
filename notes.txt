=====================================
        NODE JS CLUSTER 
=====================================

Non Blocking Operations : These are operations that have low latency and are peformed in the L1 ,L2 or L3 cache and the RAM of the device 
Blocking Operations : This have high latency and involves high computing resources . example Disk Ops and Network calls 

Javascript is single threaded meaning we have just one execution stack [brilliant!!!]

The cluster module allows us to take advantage of multicore system in our nodejs applications , by utilizing 
child processes which share the same server port and distribute incoming connections 

Worker processes are spawn using the fork() method and can communicate with the master process using IPC channels [Inter process communication channel]

They allow communication between worker processes and child proccess and vice versa 

To distribute incoming connections cluster module supports two methods 

1) Round Robbin : Master process accepts new connections in a given port and distributes them to worker processes in a round -robin fashion

2)  Sockets : Master process creates a listen socket and sends to worker process which accepts connections directly 


The OS module which is a native nodejs library allows us to know the cpu count of our machine 

os.cpus() -> this returns an array containing info about each logical cpu unit 
os.cpus().length -> returns the number of logical processors 


========================================
LOAD TEST UTILITY 
========================================
This is a software utility used to test the number of concurrent requests 

It takes parameters like 

-n : Sets the number of requests 
-c : Sets the number of concurrent requests 
--rps : Sets the number of requests per second 

example of command  loadtest -n 1000 -c 100 --rps 200 http://localhost:3000?number=10


ARTILLERY

Artillery also takes some parameters

- quick  : used for adhoc testing 

--count  : used for creating virtual users 

- n : number of requests per virtual user 

example of command would be  artillery -quick --count 10  -n 20  http://localhost:3000?number=10



==========================
      PM2
========================

PM2 (Process Manager 2) is a production-ready process manager for Node.js applications.
It provides a robust set of features to manage and monitor Node.js processes in a production environment.
Here are some advantages of using PM2:

Process Management: PM2 simplifies process management by allowing you to start, stop, restart,
 and monitor your Node.js applications with a single command. It automatically manages process lifecycle,
  ensuring that your application stays online and can handle crashes or unexpected failures.

Cluster Mode: PM2 supports running applications in cluster mode, where multiple instances of the application
 can run simultaneously across different CPU cores. This enables efficient utilization of system resources and 
 improved performance by handling  multiple requests concurrently.

Zero-Downtime Reload: PM2 allows you to perform zero-downtime reloads of your Node.js application. 
When you update your application's code, PM2 can seamlessly restart the processes one by one, ensuring
that your application remains available throughout the deployment process.

Logging and Log Management: PM2 collects logs generated by your application and provides convenient tools
 to manage and analyze those logs. It supports log rotation, log streaming, and log aggregation, making it
  easier to troubleshoot issues and monitor the health of your application.

Process Monitoring and Metrics: PM2 provides a dashboard and command-line interface to monitor the health and
 performance of your Node.js processes. It tracks CPU and memory usage, restarts, uptime, and other metrics, 
 helping you gain insights into the behavior of your application and identify performance bottlenecks.

Automatic Startup: PM2 can be configured to automatically start your Node.js application when
 the system boots, ensuring that your application is always running, even after a system restart.

Integration with Deployment Workflow: PM2 integrates well with deployment workflows and can
 be easily integrated with popular deployment tools like Git, Jenkins, and CI/CD pipelines.
  It allows you to automate the deployment process and streamline the management of your Node.js applications.

Overall, PM2 simplifies the management of Node.js applications in production environments, 
providing features for process management, clustering, zero-downtime reloads, logging, monitoring, and more. It helps improve the stability, 
scalability, and performance of your Node.js applications.

Some common pm2 commands include 


Start: Start an application or script with PM2.
pm2 start 

Stop: Stop a running application.
pm2 stop <app_name|app_id>

Restart: Restart a running application.
pm2 restart <app_name|app_id>


Delete: Remove an application from PM2.
pm2 delete <app_name|app_id>


List: List all running applications managed by PM2.
pm2 list

Logs: Display logs generated by an application.
pm2 logs <app_name|app_id>


Monitor: Monitor and display real-time information about CPU, memory, and other metrics of running applications.
pm2 monit


Reload: Reload an application without any downtime.
pm2 reload <app_name|app_id>

Scale: Change the number of instances running for an application in cluster mode.
pm2 scale <app_name|app_id> <number_of_instances>

Startup: Generate and configure a startup script to ensure that PM2 and your applications automatically start on system boot.
pm2 startup

Save: Save the current list of running applications to automatically resurrect them on system restart.
pm2 save



===================================
 CHILD PROCESSES 
=================================

This is provided by the nodejs native library "child_process"

this module allows u to automatically spawn new child processes 

Fork() 
This method returns an instance of the child process 
It implements the nodejs Emitter API which allows parent processes to register listener functions 
When certian events occurs in a child process , the listener functions will get executed 
Child process have built in Inter process communication channel
Each process has its own memory and their own v8 memory


